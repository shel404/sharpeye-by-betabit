// @ts-nocheck
/* eslint-disable */
/* This file was generated by Unframer for Framer project 8a429189ff65f2fa "Shareye Films", do not edit manually */
import {
  borderRadiusControl,
  defaultEvents,
  useIsBrowserSafari,
  useIsOnCanvas,
  useOnEnter,
  useOnExit,
  useRadius
} from "./chunk-OHDHQFGI.js";

// /:https://framerusercontent.com/modules/lRDHiNWNVWmE0lqtoVHP/Z4QJ2YpzpVnWRfR6Ccgg/Video.js
import { jsx as _jsx } from "react/jsx-runtime";
import { addPropertyControls, ControlType, useIsInCurrentNavigationTarget } from "unframer";
import { isMotionValue, useInView } from "unframer";
import { memo, useCallback, useEffect, useMemo, useRef, useState } from "react";
var ObjectFitType;
(function(ObjectFitType2) {
  ObjectFitType2["Fill"] = "fill";
  ObjectFitType2["Contain"] = "contain";
  ObjectFitType2["Cover"] = "cover";
  ObjectFitType2["None"] = "none";
  ObjectFitType2["ScaleDown"] = "scale-down";
})(ObjectFitType || (ObjectFitType = {}));
var SrcType;
(function(SrcType2) {
  SrcType2["Video"] = "Upload";
  SrcType2["Url"] = "URL";
})(SrcType || (SrcType = {}));
function getProps(props) {
  const { width, height, topLeft, topRight, bottomRight, bottomLeft, id, children, ...rest } = props;
  return rest;
}
function Video(props) {
  const newProps = getProps(props);
  return /* @__PURE__ */ _jsx(VideoMemo, { ...newProps });
}
function usePlaybackControls(videoRef) {
  const isInCurrentNavigationTarget = useIsInCurrentNavigationTarget();
  const requestingPlay = useRef(false);
  const setProgress = useCallback((rawProgress) => {
    if (!videoRef.current) return;
    const newProgress = (rawProgress === 1 ? 0.999 : rawProgress) * videoRef.current.duration;
    const isAlreadySet = Math.abs(videoRef.current.currentTime - newProgress) < 0.1;
    if (videoRef.current.duration > 0 && !isAlreadySet) {
      videoRef.current.currentTime = newProgress;
    }
  }, []);
  const play = useCallback(() => {
    const isPlaying = videoRef.current.currentTime > 0 && videoRef.current.onplaying && !videoRef.current.paused && !videoRef.current.ended && videoRef.current.readyState > videoRef.current.HAVE_CURRENT_DATA;
    if (!isPlaying && videoRef.current && !requestingPlay.current && isInCurrentNavigationTarget) {
      requestingPlay.current = true;
      videoRef.current.play().catch((e) => {
      }).finally(() => requestingPlay.current = false);
    }
  }, []);
  const pause = useCallback(() => {
    if (!videoRef.current || requestingPlay.current) return;
    videoRef.current.pause();
  }, []);
  return { play, pause, setProgress };
}
function useAutoplayBehavior({ playingProp, muted, loop, playsinline, controls }) {
  const [initialPlayingProp] = useState(() => playingProp);
  const [hasPlayingPropChanged, setHasPlayingPropChanged] = useState(false);
  if (playingProp !== initialPlayingProp && !hasPlayingPropChanged) {
    setHasPlayingPropChanged(true);
  }
  const behavesAsGif = (
    // passing `playing === true` on mount indicates that the video should
    // autoplay, like a GIF
    initialPlayingProp && muted && loop && playsinline && !controls && // Some users of the <Video> component use it by wrapping it with
    // another smart component and adding their own controls on top. (The
    // controls use transitions to control the video: e.g., when clicking
    // the play button, the smart component will transition to a state with
    // <Video playing={true} />.) In this case, we don't want the video to
    // behave as a gif, as it will be weird if the video suddenly started
    // acting as such (and auto-pausing when leaving the viewport) as soon
    // as the site visitor mutes it and clicks “Play”.
    !hasPlayingPropChanged
  );
  let autoplay;
  if (behavesAsGif) autoplay = "on-viewport";
  else if (initialPlayingProp) autoplay = "on-mount";
  else autoplay = "no-autoplay";
  return autoplay;
}
var isMountedAndReadyForProgressChanges = false;
var VideoMemo = /* @__PURE__ */ memo(function VideoInner(props) {
  const { srcType, srcFile, srcUrl, playing: playingProp, muted, playsinline, controls, progress, objectFit, backgroundColor, onSeeked, onPause, onPlay, onEnd, onClick, onMouseEnter, onMouseLeave, onMouseDown, onMouseUp, poster, posterEnabled, startTime: startTimeProp, volume, loop } = props;
  const videoRef = useRef();
  const isSafari = useIsBrowserSafari();
  const wasPausedOnLeave = useRef(null);
  const wasEndedOnLeave = useRef(null);
  const isOnCanvas = useIsOnCanvas();
  const borderRadius = useRadius(props);
  const autoplayBehavior = isOnCanvas ? "no-autoplay" : useAutoplayBehavior({ playingProp, muted, loop, playsinline, controls });
  const isInViewport = isOnCanvas ? true : useInView(videoRef);
  const startTime = startTimeProp === 100 ? 99.9 : startTimeProp;
  const { play, pause, setProgress } = usePlaybackControls(videoRef);
  useEffect(() => {
    if (isOnCanvas) return;
    if (playingProp) play();
    else pause();
  }, [playingProp]);
  useEffect(() => {
    if (isOnCanvas) return;
    if (autoplayBehavior !== "on-viewport") return;
    if (isInViewport) play();
    else pause();
  }, [autoplayBehavior, isInViewport]);
  useEffect(() => {
    if (!isMountedAndReadyForProgressChanges) {
      isMountedAndReadyForProgressChanges = true;
      return;
    }
    const rawProgressValue = isMotionValue(progress) ? progress.get() : (progress !== null && progress !== void 0 ? progress : 0) * 0.01;
    setProgress(
      // When the progress value exists (e.g. <Video startTime={10}
      // progress={50} />), we respect the `progress` value over
      // `startTime`, even if `startTime` changes. That’s because
      // `startTime` == start == changing it shouldn’t affect the current
      // progress
      (rawProgressValue !== null && rawProgressValue !== void 0 ? rawProgressValue : 0) || // Then why fall back to `startTime` when `progress` doesn’t exist,
      // you might ask? Now, that’s for
      // - canvas UX: we want the video progress to change when the user
      //   is scrobbling the “Start Time” in component settings.
      // - backwards compatibility: maybe some users *are* scrobbling
      //   using `startTime` instead of `progress`? We don’t know, and it
      //   always supported it, so let’s not break it
      (startTime !== null && startTime !== void 0 ? startTime : 0) / 100
    );
  }, [startTime, srcFile, srcUrl, progress]);
  useEffect(() => {
    if (!isMotionValue(progress)) return;
    return progress.on("change", (value) => setProgress(value));
  }, [progress]);
  useOnEnter(() => {
    if (wasPausedOnLeave.current === null) return;
    if (videoRef.current) {
      if (!wasEndedOnLeave && loop || !wasPausedOnLeave.current) play();
    }
  });
  useOnExit(() => {
    if (videoRef.current) {
      wasEndedOnLeave.current = videoRef.current.ended;
      wasPausedOnLeave.current = videoRef.current.paused;
      pause();
    }
  });
  const src = useMemo(() => {
    let fragment = "";
    if (srcType === "URL") return srcUrl + fragment;
    if (srcType === "Upload") return srcFile + fragment;
  }, [srcType, srcFile, srcUrl, startTime]);
  useEffect(() => {
    if (isSafari && videoRef.current && autoplayBehavior === "on-mount") {
      setTimeout(() => play(), 50);
    }
  }, []);
  useEffect(() => {
    if (videoRef.current && !muted) videoRef.current.volume = (volume !== null && volume !== void 0 ? volume : 0) / 100;
  }, [volume]);
  const handleReady = () => {
    if (!videoRef.current) return;
    if (videoRef.current.currentTime < 0.3) setProgress((startTime !== null && startTime !== void 0 ? startTime : 0) * 0.01);
    if (autoplayBehavior === "on-mount") play();
  };
  return /* @__PURE__ */ _jsx("video", { onClick, onMouseEnter, onMouseLeave, onMouseDown, onMouseUp, src, loop, ref: videoRef, onSeeked: (e) => onSeeked === null || onSeeked === void 0 ? void 0 : onSeeked(e), onPause: (e) => onPause === null || onPause === void 0 ? void 0 : onPause(e), onPlay: (e) => onPlay === null || onPlay === void 0 ? void 0 : onPlay(e), onEnded: (e) => onEnd === null || onEnd === void 0 ? void 0 : onEnd(e), autoPlay: autoplayBehavior === "on-mount", preload: autoplayBehavior !== "on-mount" && posterEnabled ? "metadata" : "auto", poster: posterEnabled ? poster : void 0, onLoadedData: handleReady, controls, muted: isOnCanvas ? true : muted, playsInline: playsinline, style: { cursor: !!onClick ? "pointer" : "auto", width: "100%", height: "100%", borderRadius, display: "block", objectFit, backgroundColor, objectPosition: "50% 50%" } });
});
Video.displayName = "Video";
Video.defaultProps = { srcType: "URL", srcUrl: "https://assets.mixkit.co/videos/preview/mixkit-shining-sun-in-the-sky-surrounded-by-moving-clouds-31793-small.mp4", srcFile: "", posterEnabled: false, controls: false, playing: true, loop: true, muted: true, playsinline: true, restartOnEnter: false, objectFit: "cover", backgroundColor: "rgba(0,0,0,0)", radius: 0, volume: 25, startTime: 0 };
var groupsRegex = /[A-Z]{2,}|[A-Z][a-z]+|[a-z]+|[A-Z]|\d+/gu;
function capitalizeFirstLetter(value) {
  return value.charAt(0).toUpperCase() + value.slice(1);
}
function titleCase(value) {
  const groups = value.match(groupsRegex) || [];
  return groups.map(capitalizeFirstLetter).join(" ");
}
var objectFitOptions = ["cover", "fill", "contain", "scale-down", "none"];
addPropertyControls(Video, {
  srcType: { type: ControlType.Enum, displaySegmentedControl: true, title: "Source", options: ["URL", "Upload"] },
  srcUrl: { type: ControlType.String, title: "URL", placeholder: "../example.mp4", hidden(props) {
    return props.srcType === "Upload";
  }, description: "Hosted video file URL. For YouTube, use the YouTube component." },
  srcFile: { type: ControlType.File, title: "File", allowedFileTypes: ["mp4", "webm"], hidden(props) {
    return props.srcType === "URL";
  } },
  playing: { type: ControlType.Boolean, title: "Playing", enabledTitle: "Yes", disabledTitle: "No" },
  posterEnabled: { type: ControlType.Boolean, title: "Poster", enabledTitle: "Yes", disabledTitle: "No" },
  poster: { type: ControlType.Image, title: " ", hidden: ({ posterEnabled }) => !posterEnabled },
  backgroundColor: { type: ControlType.Color, title: "Background" },
  ...borderRadiusControl,
  startTime: { title: "Start Time", type: ControlType.Number, min: 0, max: 100, step: 0.1, unit: "%" },
  loop: { type: ControlType.Boolean, title: "Loop", enabledTitle: "Yes", disabledTitle: "No" },
  objectFit: { type: ControlType.Enum, title: "Fit", options: objectFitOptions, optionTitles: objectFitOptions.map(titleCase) },
  // restartOnEnter: {
  //     type: ControlType.Boolean,
  //     title: "On ReEnter",
  //     enabledTitle: "Restart",
  //     disabledTitle: "Resume",
  // },
  controls: { type: ControlType.Boolean, title: "Controls", enabledTitle: "Show", disabledTitle: "Hide" },
  muted: { type: ControlType.Boolean, title: "Muted", enabledTitle: "Yes", disabledTitle: "No" },
  volume: { type: ControlType.Number, max: 100, min: 0, unit: "%", hidden: ({ muted }) => muted },
  onEnd: { type: ControlType.EventHandler },
  onSeeked: { type: ControlType.EventHandler },
  onPause: { type: ControlType.EventHandler },
  onPlay: { type: ControlType.EventHandler },
  ...defaultEvents
});

export {
  Video
};
